<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.helbing.cn/"/>
  <updated>2019-05-20T05:44:17.765Z</updated>
  <id>https://blog.helbing.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Travis 部署 Hexo 博客</title>
    <link href="https://blog.helbing.cn/2019/02/04/deploy-hexo-blog-with-travis/"/>
    <id>https://blog.helbing.cn/2019/02/04/deploy-hexo-blog-with-travis/</id>
    <published>2019-02-04T00:00:00.000Z</published>
    <updated>2019-05-20T05:44:17.765Z</updated>
    
    <content type="html"><![CDATA[<p>首先我是默认看这篇博文的你是已经有自己的静态博客了，只是还缺少一套可以自动化部署博客的手段。因为我的电脑是 macOS 操作系统，所以博文中的操作都是基本 macOS 操作系统的，Windows 操作系统上不一定适用</p><h2 id="注册登录-Travis"><a href="#注册登录-Travis" class="headerlink" title="注册登录 Travis"></a>注册登录 Travis</h2><p>打开 Chrome 浏览器，进入 Travis 的<a href="https://travis-ci.com" target="_blank" rel="noopener">官网</a>，记住是 <code>.com</code> 结尾的，而不是 <code>.org</code> 结尾的。接下来凭你的直觉去添加项目</p><p><img src="https://tuchuang-1253782374.cos.ap-guangzhou.myqcloud.com/20190204090319.png" alt></p><h2 id="安装-Travis"><a href="#安装-Travis" class="headerlink" title="安装 Travis"></a>安装 Travis</h2><p>在安装 Travis 前首先我们得重新安装 Ruby 环境，macOS 自带的 Ruby 环境太老了</p><pre><code class="bash">brew install ruby</code></pre><p>添加环境变量，由于我用的是 zsh ，所以我是在 <code>~/.zshrc</code> 中添加环境变量</p><pre><code class="bash"># rubyexport PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;# gemexport PATH=&quot;$PATH:`gem env gemdir`/bin&quot;</code></pre><p>重新加载配置</p><pre><code class="bash">source ~/.zshrc</code></pre><p>进入正戏，开始安装 Travis</p><pre><code class="bash">gem install travis</code></pre><p>执行下 <code>travis</code>，如果有反应说明就是安装完成了</p><h2 id="登录-Travis"><a href="#登录-Travis" class="headerlink" title="登录 Travis"></a>登录 Travis</h2><p>到你的博客目录执行</p><pre><code class="bash">travis login --com --auto</code></pre><p>按照它的提示进行输入即可登录成功</p><h2 id="申请-GITHUB-TOKEN"><a href="#申请-GITHUB-TOKEN" class="headerlink" title="申请 GITHUB_TOKEN"></a>申请 GITHUB_TOKEN</h2><p>打开 Github 的 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal access tokens</a>，然后点击 <code>Generate new token</code> 按钮</p><p><img src="https://tuchuang-1253782374.cos.ap-guangzhou.myqcloud.com/20190204091334.png" alt></p><p>权限部分我们只需要勾选 <code>repo</code></p><p>为了防止 GITHUB TOKEN 泄露，我们添加一个环境变量。在你的 Travis 项目中对应的 Setting (More options -&gt; Settings) 页面添加环境变量</p><p><img src="https://tuchuang-1253782374.cos.ap-guangzhou.myqcloud.com/20190204092112.png" alt></p><h2 id="配置-travis-yml"><a href="#配置-travis-yml" class="headerlink" title="配置 .travis.yml"></a>配置 .travis.yml</h2><p>在你的博客根目录新建 <code>.travis.yml</code></p><pre><code class="yaml">language: node_jssudo: requirednode_js: stablecache:  yarn: true  directories:    - node_modulesbranchs:  only:    - masterbefore_script:  - curl -o- -L https://yarnpkg.com/install.sh | bash  - export PATH=&quot;$HOME/.yarn/bin:$PATH&quot;  - yarn install  - yarn global add hexo-cliscript:  - hexo clean  - hexo generate# 部署方式为 github page# master 分支有提交的话触发 Travis 自动部署# 编译完成后，将 public/ 目录下的代码提交到仓库的 gh-pages 分支deploy:  provider: pages  skip-cleanup: true  github-token: $GITHUB_TOKEN  keep-history: true  on:    branch: master  target-branch: gh-pages  local-dir: public/  verbose: true</code></pre><p>之后当你在 master 分支提交代码后，就会自动触发部署了</p><h2 id="配置自定义域名"><a href="#配置自定义域名" class="headerlink" title="配置自定义域名"></a>配置自定义域名</h2><p>Github page 提供自定义域名配置，打开你的博客仓库的的 Settings 页面进行配置</p><p><img src="https://tuchuang-1253782374.cos.ap-guangzhou.myqcloud.com/20190208001910.png" alt></p><p>然后在博客根目录的 <code>source</code> 目录下添加一个 <code>CNAME</code> 文件，然后写入你的域名</p><pre><code class="bash">blog.helbing.cn</code></pre><p>不用担心 HTTPS 证书的问题，只要你勾选了 <code>Enforce HTTPS</code>，Github 会自动帮你到 <a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a> 那里申请免费的 HTTPS 证书</p>]]></content>
    
    <summary type="html">
    
      相信很多人都有自己的静态博客，但是部署方式可能不是采用自动化部署的方式。像我之前就是通过手动编译和部署的方式来部署我的博客到VPS上，Travis 是一款免费的自动化部署工具，接下来我将介绍如何用 Travis 来部署静态博客
    
    </summary>
    
    
      <category term="travis" scheme="https://blog.helbing.cn/tags/travis/"/>
    
      <category term="git" scheme="https://blog.helbing.cn/tags/git/"/>
    
      <category term="hexo" scheme="https://blog.helbing.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>深入了解 Laravel 5.5 包自动发现</title>
    <link href="https://blog.helbing.cn/2018/11/03/package-auto-discovery/"/>
    <id>https://blog.helbing.cn/2018/11/03/package-auto-discovery/</id>
    <published>2018-11-03T00:00:00.000Z</published>
    <updated>2019-05-20T05:44:17.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>第三方包只需要在自己的 composer.json 文件中加入需要注册的 ServiceProvider 和 Facade，laravel 的 package auto discovery 就会自动发现并注册</p><pre><code class="json">&quot;extra&quot;: {    &quot;laravel&quot;: {        &quot;providers&quot;: [            &quot;Barryvdh\\Debugbar\\ServiceProvider&quot;        ],        &quot;aliases&quot;: {            &quot;Debugbar&quot;: &quot;Barryvdh\\Debugbar\\Facade&quot;        }    }},</code></pre><p>如果你不想 laravel 对某个包做自动发现，你可以在你 laravel 项目的 composer.json 中加入</p><pre><code class="json">&quot;extra&quot;: {    &quot;laravel&quot;: {        &quot;dont-discover&quot;: &quot;barryvdh/laravel-debugbar&quot;    }},</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><pre><code class="json">&quot;scripts&quot;: {    &quot;post-root-package-install&quot;: [        &quot;@php -r \&quot;file_exists(&#39;.env&#39;) || copy(&#39;.env.example&#39;, &#39;.env&#39;);\&quot;&quot;    ],    &quot;post-create-project-cmd&quot;: [        &quot;@php artisan key:generate --ansi&quot;    ],    &quot;post-autoload-dump&quot;: [        &quot;Illuminate\\Foundation\\ComposerScripts::postAutoloadDump&quot;,        &quot;@php artisan package:discover --ansi&quot;    ]},</code></pre><p>laravel 的 package auto discovery 主要是通过<code>php artisan package:discover --ansi</code>这条命令来执行的，这条命令位于<code>Illuminate\Foundation\Console\PackageDiscoverCommand</code>这个类中，这个类会调用<code>Illuminate\Foundation\PackageManifest</code>的 build 方法来做自动发现</p><pre><code class="php">public function build(){    $packages = [];    // installed.json是composer在安装完所有包后会自动生成的文件，其实就是所有包的composer.json的集合    if ($this-&gt;files-&gt;exists($path = $this-&gt;vendorPath . &#39;/composer/installed.json&#39;)) {        $packages = json_decode($this-&gt;files-&gt;get($path), true);    }    // $this-&gt;packagesToIgnore()会获取到当前laravel项目的composer.json中不需要做自动发现的包    $ignoreAll = in_array(&#39;*&#39;, $ignore = $this-&gt;packagesToIgnore());    // 这个很长的调用其实是获取到每一个需要自动注册的ServiceProvider和Facade    // 然后将结果作为参数传入write方法    $this-&gt;write(collect($packages)-&gt;mapWithKeys(function ($package) {        return [$this-&gt;format($package[&#39;name&#39;]) =&gt; $package[&#39;extra&#39;][&#39;laravel&#39;] ?? []];    })-&gt;each(function ($configuration) use (&amp;$ignore) {        $ignore = array_merge($ignore, $configuration[&#39;dont-discover&#39;] ?? []);    })-&gt;reject(function ($configuration, $package) use ($ignore, $ignoreAll) {        return $ignoreAll || in_array($package, $ignore);    })-&gt;filter()-&gt;all());}protected function write(array $manifest){    // $this-&gt;manifestPath这个的值从哪里来的？你可以去看Illuminate\Foundation\Application的registerBaseBindings方法    // $this-&gt;manifestPath的值一般会是bootstrap/cache/packages.php    if (!is_writable(dirname($this-&gt;manifestPath))) {        throw new Exception(&#39;The &#39; . dirname($this-&gt;manifestPath) . &#39; directory must be present and writable.&#39;);    }    // 单纯的把自动发现到的ServiceProvider和Facade写入到文件中    $this-&gt;files-&gt;replace(        $this-&gt;manifestPath,        &#39;&lt;?php return &#39; . var_export($manifest, true) . &#39;;&#39;    );}</code></pre><p>然后这条命令就算是执行完成了，单纯的只是做了自动发现，那么自动注册呢？</p><p>全局搜索 PackageManifest，可以发现<code>Illuminate\Foundation\Application</code>中的 registerConfiguredProviders 有调用到</p><pre><code class="php">public function registerConfiguredProviders(){    // 获取到app.php中所有需要注册的ServiceProvider    $providers = Collection::make($this-&gt;config[&#39;app.providers&#39;])        -&gt;partition(function ($provider) {            return Str::startsWith($provider, &#39;Illuminate\\&#39;);        });    // 获取到自动发现到的所有需要注册的ServiceProvider    $providers-&gt;splice(1, 0, [$this-&gt;make(PackageManifest::class)-&gt;providers()]);    // 这里函数调用会去注册ServiceProvider    (new ProviderRepository($this, new Filesystem(), $this-&gt;getCachedServicesPath()))        -&gt;load($providers-&gt;collapse()-&gt;toArray());}</code></pre><p>继续全局搜索 PackageManifest，可以发现<code>Illuminate\Foundation\Bootstrap\RegisterFacades</code>中的 bootstrap 有调用到</p><pre><code class="php">public function bootstrap(Application $app){    Facade::clearResolvedInstances();    Facade::setFacadeApplication($app);    // 注册Facade    AliasLoader::getInstance(array_merge(        // 获取到app.php中所有需要注册的Facade        $app-&gt;make(&#39;config&#39;)-&gt;get(&#39;app.aliases&#39;, []),        // 获取到自动发现到的所有需要注册的Facade        $app-&gt;make(PackageManifest::class)-&gt;aliases()    ))-&gt;register();}</code></pre>]]></content>
    
    <summary type="html">
    
      laravel5.5 开始提供了一个新特性，包自动发现 Package Auto Discuvery，包自动发现主要用于自动发现第三方包的 ServiceProvider 和 Facade 并进行注册
    
    </summary>
    
    
      <category term="php" scheme="https://blog.helbing.cn/tags/php/"/>
    
      <category term="laravel" scheme="https://blog.helbing.cn/tags/laravel/"/>
    
  </entry>
  
</feed>
